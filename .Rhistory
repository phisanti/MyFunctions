library(MyFunctions)
library(MyFunctions)
library(MyFunctions)
library(MyFunctions)
kde2dCpp(1:100, rnorm(100))
devtools::document()
library(MyFunctions)
library(MyFunctions)
library(MyFunctions)
library(MyFunctions)
roxygenize()
library(roxygen2)
roxygenize()
library(MyFunctions)
kde2dCpp(rnorm(100), 1:100)
library(MyFunctions)
devtools::use_rcpp(pkg = 'MyFunctions')
library(MyFunctions)
library(MyFunctions)
kde2dCpp(rnorm(100), 1:100)
eigenTransMatMult(1,1)
library(MyFunctions)
eigenMapMatMult(1,1)
Gaussian_GS <- function(x, niter = 2000, prior.mu = 0, prior.sd =1) {
# Default priors
if (prior.mu == 0) {prio.mu <- mean(x)} # Fill prior mu with empirical mu
if (prior.sd == 1) {prio.sd <- sd(x)} # Fill prior sd with empirical sd
mu.cur <- prior.mu
psi.cur <- 1/prio.sd^2 # Calculate psi
# Output matrix
sim.gibbs <- matrix(0, nrow = niter + 1, ncol = 2)
colnames(sim.gibbs) <- c('mu', 'sigma')
# Initial values
mu.cur <- mu.cur + rnorm(1, sd = 0.2)
psi.cur <- psi.cur * exp(rnorm(1, sd = 0.2))
sim.gibbs[1, 1] <- mu.cur
sim.gibbs[1, 2] <- psi.cur
n <- length(x)
# Sampling
xbar <- mean(x)
for (i in 0:niter) {
mu.cur <- rnorm(1, mean = xbar, sd = 1 / sqrt(n * psi.cur)) # Sample mean
psi.cur <- rgamma(1, n/2, 0.5 * sum( (x - mu.cur)^2 )) # Sample sigma
sim.gibbs[i + 1, 1] <- mu.cur
sim.gibbs[i + 1, 2] <- psi.cur
}
# Transform psi to sigma
sim.gibbs[,2] <- 1/sqrt(sim.gibbs[,2])
return(sim.gibbs)
}
x <- rnom(20, 0, 2)
post <- Gaussian_GS(x)
apply(post, 2, mean)
plot(post[,1],1:ncol(m), type = "l")
x <- rnom(20, 0, 2)
x <- rnorm(20, 0, 2)
post <- Gaussian_GS(x)
apply(post, 2, mean)
plot(post[,1],1:ncol(m), type = "l")
plot(post[,1],1:ncol(post), type = "l")
1:ncol(post)
plot(post[,1],seq(along = post[,1]), type = "l")
plot(y = post[,1],x =seq(along = post[,1]), type = "l")
plot(y = post[,2],x =seq(along = post[,2]), type = "l")
library(MyFunctions)
library(MyFunctions)
library(MyFunctions)
library(MyFunctions)
#' @title Gibbs Sampling from a normal distribution
#' @description Manual implementation of basic gibbs sampling from normal distribution
#' @param x Numeric vector
#' @param niter Number of iterations to extract samples
#' @param prior.mu Starting value of mu
#' @param prior.sd Starting value of sigma
#'
#' @author Santiago Ca単o-Mu単iz
#' @export
Gaussian_GS <- function(x, niter = 2000, prior.mu = 0, prior.sd =1, burn.in = 100) {
# Default priors
if (prior.mu == 0) {prio.mu <- mean(x)} # Fill prior mu with empirical mu
if (prior.sd == 1) {prior.sd <- sd(x)} # Fill prior sd with empirical sd
mu.cur <- prior.mu
psi.cur <- 1/prior.sd^2 # Calculate psi
# Output matrix
sim.gibbs <- matrix(0, nrow = niter + 1, ncol = 2)
colnames(sim.gibbs) <- c('mu', 'sigma')
# Initial values
mu.cur <- mu.cur + rnorm(1, sd = 0.2)
psi.cur <- psi.cur * exp(rnorm(1, sd = 0.2))
sim.gibbs[1, 1] <- mu.cur
sim.gibbs[1, 2] <- psi.cur
n <- length(x)
# Sampling
xbar <- mean(x)
for (i in 0:niter) {
mu.cur <- rnorm(n = 1, mean = xbar, sd = 1 / sqrt(n * psi.cur)) # Sample mean
psi.cur <- rgamma(n = 1, shape =  n/2, scale = 0.5 * sum( (x - mu.cur)^2 )) # Sample sigma
sim.gibbs[i + 1, 1] <- mu.cur
sim.gibbs[i + 1, 2] <- psi.cur
}
sim.gibbs <- sim.gibbs[1:burn.in,] # Remove burn.in
# Transform psi to sigma
sim.gibbs[,2] <- 1/sqrt(sim.gibbs[,2])
return(sim.gibbs)
}
library(MyFunctions)
library(MyFunctions)
library(MyFunctions)
library(MyFunctions)
library(MyFunctions)
#' @title Gibbs Sampling from a normal distribution
#' @description Manual implementation of basic gibbs sampling from normal distribution
#' @param x Numeric vector
#' @param niter Number of iterations to extract samples
#' @param prior.mu Starting value of mu
#' @param prior.sd Starting value of sigma
#' @param burn.in Warm up samples
#'
#' @author Santiago Ca単o-Mu単iz
#' @export
Gaussian_GS <- function(x, niter = 2000, prior.mu = 0, prior.sd =1) {
# Default priors
if (prior.mu == 0) {prio.mu <- mean(x)} # Fill prior mu with empirical mu
if (prior.sd == 1) {prior.sd <- sd(x)} # Fill prior sd with empirical sd
mu.cur <- prior.mu
psi.cur <- 1/prior.sd^2 # Calculate psi
# Output matrix
sim.gibbs <- matrix(0, nrow = niter + 1, ncol = 2)
colnames(sim.gibbs) <- c('mu', 'sigma')
# Initial values
mu.cur <- mu.cur + rnorm(1, sd = 0.2)
psi.cur <- psi.cur * exp(rnorm(1, sd = 0.2))
sim.gibbs[1, 1] <- mu.cur
sim.gibbs[1, 2] <- psi.cur
n <- length(x)
# Sampling
xbar <- mean(x)
for (i in 0:niter) {
mu.cur <- rnorm(1, mean = xbar, sd = 1 / sqrt(n * psi.cur)) # Sample mean
psi.cur <- rgamma(1, n/2, 0.5 * sum( (x - mu.cur)^2 )) # Sample sigma
sim.gibbs[i + 1, 1] <- mu.cur
sim.gibbs[i + 1, 2] <- psi.cur
}
# Transform psi to sigma
sim.gibbs[,2] <- 1/sqrt(sim.gibbs[,2])
return(sim.gibbs)
}
library(MyFunctions)
library(MyFunctions)
library(MyFunctions)
?MASS::kde2d()
